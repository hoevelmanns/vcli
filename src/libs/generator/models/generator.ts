import {
    initProject,
    makeClassName,
    makeFileName,
    makeFunctionName,
    makePath,
    projectConfig,
} from '../../shared/utils';
import { CommandTemplate, CommandType, ConsoleCommand } from '../types';
import { cliCommandTemplate, shellCommandTemplate } from '../templates';
import { ExternalConsole } from '../../shared/types';
import { shell } from '../../shell/models';
import { relative } from 'path';
import * as fs from 'fs';
import cli from 'cli-ux';

/**
 * todo: refactoring
 */
export class Generator {
    private ignoreCommands = ['list', 'help'];
    private commands: ConsoleCommand[] = [];
    private console = <ExternalConsole>{};
    private processedCommands: string[] = [];
    private runInVagrant = false;
    private cliCommandTemplates: CommandTemplate[] = [];
    private shellCommandTemplates: CommandTemplate[] = [];
    private shellCommandFile = this.cliRoot + `${projectConfig.generatorOutput}/generated.ts`;
    private cliCommandsPath = this.cliRoot + '/src/commands/'; // todo move to types

    constructor(private cliRoot: string) {}

    /**
     * todo description
     */
    run = async (runInVagrant = false): Promise<void> =>
        Object.entries(projectConfig?.consoles).forEach((c) => {
            this.console = { ...c[1], ...{ context: c[0] } }; // todo check

            // todo write shell-command
            shell
                .exec({
                    command: `${this.console.executable} ${this.console.list}`,
                    vagrant: this.runInVagrant || runInVagrant,
                    displayText: 'Generating shell and cli commands',
                })
                .subscribe((content) => {
                    this.parseConsoleList(content);
                    this.generateTemplates();
                    this.writeShellCommands();
                    this.writeCliCommands();
                    // update cli commands -> prepack

                    // todo write shell-command (or operator?)
                    shell
                        .exec({
                            displayText: 'Update CLI Manifest & Readme',
                            command: `cd ${this.cliRoot} && npm run prepack`,
                        })
                        .toPromise();
                });
        });

    /**
     *
     * todo description
     *
     * @param description
     * @param command
     */
    addCommand = (description: string, command: string): void | number =>
        this.commands.push({
            name: command,
            description,
            execute: `${this.console.executable} ${command}`,
            type: CommandType.external,
            context: this.console.context ?? 'unknown',
        });

    /**
     * todo description
     *
     * @param content
     */
    private parseConsoleList = (content: string): void => {
        // removes all contents until given "parserStartSting"
        content = content.substr(
            content.indexOf(this.console.parserStartString) + this.console.parserStartString.length,
        );

        const lines = content.split('\n');

        lines.forEach((line) => {
            const command = line.trim().split(' ')[0];
            const description = line.replace(command, '').trim();

            if (this.ignoreCommands.includes(command)) return;
            // todo check if error occurred
            if (command && description) this.addCommand(description, command);
        });
    };

    /**
     *
     */
    private generateTemplates = (): void => {
        this.commands.forEach((command) => {
            const className = makeClassName(command.name);

            if (this.processedCommands.includes(className)) {
                return cli.info(`Command "${command.name}" already exist. Skipped generating.`);
            }

            this.processedCommands.push(className);
            this.shellCommandTemplates.push({ command, template: shellCommandTemplate(command) });

            // todo adds flags -> execute bin/console <command> -h -> bin/console sw:plugin:activate -h
            this.cliCommandTemplates.push({ command, template: cliCommandTemplate(command, this.cliRoot) });
            this.processedCommands.push(className);
        });
    };

    /**
     * @returns void
     */
    private writeShellCommands = (): void => {
        const fileHead = [
            '/* tslint:disable */\n/**\n* This file was automatically generated by vcli.\n* DO NOT MODIFY IT BY HAND. Instead, run "vc refresh" to regenerate this file.\n*/\n\n',
            'import { ShellCommand } from "../libs/shell/models";\n',
        ];

        const fileContent = fileHead.join('') + this.shellCommandTemplates.map((item) => item.template).join('');

        fs.writeFileSync(this.shellCommandFile, fileContent, { flag: 'w' });
    };

    /**
     * @todo abstract
     */
    private writeCliCommands = async (): Promise<void> => {
        await initProject();
        this.cliCommandTemplates.map((cmdTemplate: CommandTemplate) => {
            const targetPath = this.cliCommandsPath + makePath(cmdTemplate.command.name);
            const shellCommandPath = relative(targetPath, this.cliRoot + '/src/shell-commands/');
            const targetFile = targetPath + '/' + makeFileName(cmdTemplate.command.name);

            cmdTemplate.template = [
                `import { ${makeFunctionName(cmdTemplate.command.name)} } from "${shellCommandPath}";`,
                cmdTemplate.template,
            ].join('');

            fs.mkdirSync(targetPath, { recursive: true });
            fs.writeFileSync(targetFile, cmdTemplate.template, { flag: 'w' });
        });
    };

    get vagrant() {
        this.runInVagrant = true;
        return this;
    }
}
